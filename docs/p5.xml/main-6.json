{"format": "json", "view": "div", "doc": "p5.xml", "root": "1.7.2.17", "id": "CH", "odd": "tei.odd", "next": "1.7.4.2", "previous": "1.7.2.15", "nextId": "ST", "previousId": "SG", "switchView": null, "content": "<!DOCTYPE html>\n\n<div class=\"content\"><section class=\"tei-div9\" data-tei=\"1.7.2.17\" id=\"CH\">\n<h1 class=\"tei-head9\" data-tei=\"1.7.2.17.5\">6 Languages and Character Sets</h1>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.7\">The documents which users of these Guidelines may wish to encode\nencompass all kinds of material, potentially expressed in the full\nrange of written and spoken human languages, including the extinct,\nthe non-existent, and the conjectural. Because of this wide scope,\nspecial attention has been paid to two particular aspects of the\nrepresentation of linguistic information often taken for granted:\nlanguage identification and character encoding.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.9\">Even within a single document, material in many different languages\nmay be encountered. Human culture, and the texts which embody it, is\nintrinsically multilingual, and shows no sign of ceasing to be so.\nTraditional philologists and modern computational linguists alike work\nin a polyglot world, in which code-switching (in the linguistic sense)\nand accurate representation of differing language systems constitute\nthe norm, not the exception. The current increased interest in studies\nof linguistic diversity, most notably in the recording and\ndocumentation of endangered languages, is one aspect of this long\nstanding tradition. Because of their historical importance, the needs\nof endangered and even extinct languages must be taken into account\nwhen formulating Guidelines and recommendations such as these. </p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.11\">Beyond the sheer number and diversity of human languages, it should\nbe remembered that in their written forms they may deploy a huge\nvariety of scripts or writing systems. These scripts are in turn\ncomposed of smaller units, which for simplicity we term here\ncharacters. A primary goal when encoding a text should be to capture\nenough information for subsequent users to correctly identify\nnot only the constituent characters, but also the language and script. In this chapter we\naddress this requirement, and propose recommended mechanisms to\nindicate the languages, scripts and characters used in a document or a\npart thereof.  </p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.13\">Identification of language is dealt with in <pb-link class=\"inner-ref\" data-tei=\"1.7.2.17.13.2\" emit=\"transcription\" hash=\"CHSH\" xml-id=\"CHSH\">6.1 Language Identification</pb-link>. In summary, it recommends the use of pre-defined\nidentifiers for a language where these are available, as they\nincreasingly are, in part as a result of the twin pressures of an\nincreasing demand for language-specific software and an increased\ninterest in language documentation. Where such identifiers are not\navailable or not standardized, these Guidelines recommend a method for\ndocumenting language identifiers and their significance, in the same\nway as other metadata is documented in the TEI header.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.15\">Standardization of the means available to represent characters and\nscripts has moved on considerably since the publication of the first\nversion of these Guidelines. At that time, it was essential to\nexplicitly document the characters and encoded character sets used by\nalmost any digital resource if it was to have any chance of being\nusable across different computer platforms or environments, but this\nis no longer the case. With the availability of the Unicode standard,\nmore than 128,000 different characters representing almost all of the world's\ncurrent writing systems are available and usable in any XML processing\nenvironment without formality. Nevertheless, however large the number\nof standardized characters, there will always be a need to encode\ndocuments which use non-standard characters and glyphs, particularly\nbut not exclusively in historical material. The second part of\nthis chapter discusses in some detail the concepts and\npractice underlying this standard, and also introduces the methods\navailable for extending beyond it, which are more fully discussed in\n<pb-link class=\"inner-ref\" data-tei=\"1.7.2.17.15.2\" emit=\"transcription\" hash=\"WD\" xml-id=\"WD\">5 Characters, Glyphs, and Writing Modes</pb-link>.</p>\n<div class=\"tei-div10\" data-tei=\"1.7.2.17.17\" id=\"CHSH\"><h2 class=\"tei-head9\" data-tei=\"1.7.2.17.17.3\">6.1 Language Identification</h2>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.17.5\">Identification of the language a document or part thereof is\nwritten in is a crucial requirement for many envisioned usages of\nan electronic document. The TEI therefore accommodates this need in the\nfollowing way:<ul class=\"tei-list3\" data-tei=\"1.7.2.17.17.5.2\"><li class=\"tei-item\" data-tei=\"1.7.2.17.17.5.2.2\">A global attribute xml:lang is defined for all TEI\n elements. Its value identifies the language and writing system\n used.</li><li class=\"tei-item\" data-tei=\"1.7.2.17.17.5.2.4\">The TEI header has a section set aside for the information\n about the languages used in a document: see further <pb-link class=\"inner-ref\" data-tei=\"1.7.2.17.17.5.2.4.2\" emit=\"transcription\" hash=\"HD41\" xml-id=\"HD41\">2.4.2 Language Usage</pb-link>.</li></ul></p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.17.7\">The value of the attribute xml:lang identifies the\nlanguage (and, optionally, script) using a coded value. For maximal compatibility with existing\nprocesses, the identifier for the language must be constructed as in\n<span class=\"tei-title5\" data-tei=\"1.7.2.17.17.7.4\">Best Current Practice 47</span><a class=\"note tei-note\" data-tei=\"1.7.2.17.17.7.5\" href=\"#fn_1_7_2_17_17_7_5\" id=\"fnref_1_7_2_17_17_7_5\" rel=\"footnote\">1</a>. This\nsame identifier has to be used to identify\nthe corresponding <a class=\"tei-gi\" data-tei=\"1.7.2.17.17.7.9\" href=\"/ref/language\" target=\"_blank\">language</a> element in the TEI header, if one\nis present.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.17.9\">The first part of BCP 47 is called <a class=\"tei-ref3\" data-tei=\"1.7.2.17.17.9.2\" href=\"#CH-BIBL-4\" target=\"\"><span class=\"tei-title5\" data-tei=\"1.7.2.17.17.9.2.2\">Tags for Identifying\nLanguages</span></a>, and proposes the following mechanism for\nconstructing an identifier (tag) for languages as administered by the\nInternet Assigned Numbers Authority (IANA). The tag is assembled from\na sequence of subtags separated by the hyphen (-, U+002D) character.\nIt gives the language (possibly further identified with a\nsublanguage), a script, and a region for the language, each possibly\nfollowed by a variant subtag.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.17.11\">The authoritative list of registered subtags is maintained by IANA\nand is available at <span class=\"tei-ptr4\" data-tei=\"1.7.2.17.17.11.2\"><a href=\"http://www.iana.org/assignments/language-subtag-registry\">http://www.iana.org/assignments/language-subtag-registry</a></span>.\nFor a good general overview of the construction of language tags, see\n<span class=\"tei-ptr4\" data-tei=\"1.7.2.17.17.11.4\"><a href=\"http://www.w3.org/International/articles/language-tags/\">http://www.w3.org/International/articles/language-tags/</a></span>,\nand for a practical step-by-step guide, see <span class=\"tei-ptr4\" data-tei=\"1.7.2.17.17.11.6\"><a href=\"https://www.w3.org/International/questions/qa-choosing-language-tags.en.php\">https://www.w3.org/International/questions/qa-choosing-language-tags.en.php</a></span>.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.17.13\">In addition to the list of registered subtags, BCP 47 provides\nextensions that can be employed by private convention. The constructs\nprovided can thus be used to generate identifiers for any language,\npast and present, in any usage in any area of the world. If such\nprivate extensions are used within the context of the TEI, they should\nbe documented within the <a class=\"tei-gi\" data-tei=\"1.7.2.17.17.13.2\" href=\"/ref/language\" target=\"_blank\">language</a> element of the TEI header,\nwhich might also provide a prose description of the language described\nby the language tag.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.17.15\">While language, region, and script can be adequately identified\nusing this mechanism, there is only very rough provision to express a\ndimension of time for the language of a document; those codes provided\n(e.g. <span class=\"tei-code2 code\" data-tei=\"1.7.2.17.17.15.2\">grc</span> for <span class=\"tei-q2\" data-tei=\"1.7.2.17.17.15.4\">Greek, Ancient (to 1453)</span>) might not\nreflect the segments appropriate for a text at hand. Text encoders\nmight express the time window of the language used in the document by\nmeans of the extension mechanism defined in BCP 47 and relate that\nto a <a class=\"tei-gi\" data-tei=\"1.7.2.17.17.15.6\" href=\"/ref/date\" target=\"_blank\">date</a> element in the corresponding <a class=\"tei-gi\" data-tei=\"1.7.2.17.17.15.8\" href=\"/ref/language\" target=\"_blank\">language</a>\nsection of the TEI header.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.17.17\">Equivalences to language identifiers by other authorities can be\ngiven in the <a class=\"tei-gi\" data-tei=\"1.7.2.17.17.17.2\" href=\"/ref/language\" target=\"_blank\">language</a> section as well, but no formal\nmechanism for doing so has been defined.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.17.19\">The scope of the language identification extends to the whole\nsubtree of the document anchored at the element that carries the\nxml:lang attribute, including all elements and those\nattributes, if any, where a language might apply.<a class=\"note tei-note\" data-tei=\"1.7.2.17.17.19.4\" href=\"#fn_1_7_2_17_17_19_4\" id=\"fnref_1_7_2_17_17_19_4\" rel=\"footnote\">2</a></p></div>\n<div class=\"tei-div10\" data-tei=\"1.7.2.17.19\" id=\"CHCS\">\n<h2 class=\"tei-head9\" data-tei=\"1.7.2.17.19.4\">6.2 Characters and Character Sets</h2>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.6\">All document encoding has to do with representing one thing by\n   another in an agreed and systematic way. Applied to the smallest\n   distinctive units in any given writing system, which for the\n   moment we may loosely call characters, such representation\n   raises surprisingly complex and troublesome issues. The reasons\n   are partly historical and partly to do with conceptual\n   unclarities about what is involved in identifying, encoding,\n   processing and rendering the characters of a natural\n   language.</p>\n<div class=\"tei-div10\" data-tei=\"1.7.2.17.19.8\" id=\"D4-41\">\n<h3 class=\"tei-head9\" data-tei=\"1.7.2.17.19.8.4\">6.2.1 Historical Considerations</h3>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.8.6\">When the first methods of representing text for storage or\n   transmission by machines were devised, long before the\n   development of computers, the overriding aim was to identify the\n   smallest set of symbols needed to convey the essential semantic\n   content, and to encode that symbol set in the most economical\n   way that the storage or transmission media allowed. The initial\n   outcome were systems that encoded only such content as could be\n   expressed in uppercase letters in the Latin script, plus a few\n   punctuation marks and some control characters needed to\n   regulate the storage and transmission devices. Such encodings,\n   originally developed for telegraphy, strongly influenced the way\n   the pioneers of computing conceived of and implemented the\n   handling of text, with consequences that are with us still.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.8.8\">For many years after the invention of computers, the way they\n   represented text continued to be constrained by the imperative\n   to use expensive resources with maximal efficiency. Even when\n   storage and processing costs began their dramatic fall, the\n   Anglo-centric outlook of  most hardware designers and software\n   engineers hampered initiatives to devise a more generous and\n   flexible model for text representation. The wish to retain\n   compatibility with legacy data was an additional disincentive.\n   Eventually, tension in East Asia between commitment to\n   technological progress and the inability of existing computers\n   to cope with local writing systems led to decisive developments.\n   Japanese, Korean, and Chinese standards bodies, who long before\n   the advent of computers had been engaged in the specification of\n   character sets, joined with computer manufacturers and software\n   houses to devise ways of mapping those character sets to numeric\n   encodings and processing the resulting text data.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.8.10\">Unfortunately, in the early years there was little or no\n   co-ordination among either the national standards bodies or the\n   manufacturers concerned, so that although commercial necessity\n   dictated that these various local standards were all compatible\n   with  the representation of US-American English, they were not\n   straightforwardly compatible with one another. Even within Japan\n   itself there emerged a number of mutually incompatible systems,\n   thanks to a mixture of commercial rivalry, disagreements about\n   how best to manage certain intractable problems, and the fact\n   that such pioneering work inevitably involved some false starts,\n   leading to incompatibilities even between successive products of\n   the same bodies. Roughly at the same time, and for similar\n   reasons, multiple and incompatible ways of representing\n   languages that use Cyrillic scripts were devised, along with\n   methods of encoding ancient writing systems which inevitably\n   could not aim for compatibility with other writing systems apart\n   from basic Latin script. Many of the earliest projects that fed\n   into the TEI were shaped in this developmental phase of the\n   computerized representation of texts, and it was also the\n   context in which SGML was devised and finalized. </p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.8.12\">SGML had of necessity to offer ways of coping with multiple\n   writing systems in multiple representations; or rather, it\n   provided a framework within which SGML-compliant applications\n   capable of handling such multiple representations might be\n   developed by those with sufficient financial and personnel\n   resources (such as are seldom found in academia). Earlier\n   editions of these Guidelines offered advice on character set and\n   writing system issues addressed to the condition of those for\n   whom SGML was the only feasible option. That advice is here\n   substantially altered because of two closely-related\n   developments: the availability of the ISO/Unicode character set\n   as an international standard, and the emergence of XML and\n   related technologies which are committed to the theory and\n   practice of character representation which Unicode embodies.\n   </p> </div>\n<div class=\"tei-div10\" data-tei=\"1.7.2.17.19.10\" id=\"D4-42\"> <h3 class=\"tei-head9\" data-tei=\"1.7.2.17.19.10.4\">6.2.2 Terminology and Key\n   Concepts</h3><p class=\"tei-p\" data-tei=\"1.7.2.17.19.10.5\">Before the significance of Unicode and the\n   implications of the association between XML and Unicode can be\n   adequately explained, it is necessary to clarify some key\n   concepts and attempt to establish an adequately precise\n   terminology for them.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.10.7\"><div class=\"tei-figure1\" data-tei=\"1.7.2.17.19.10.7.1\" id=\"fig1\">\n<img class=\"tei-graphic\" data-tei=\"1.7.2.17.19.10.7.1.3\" src=\"https://tei-c.org/release/doc/tei-p5-doc/en/html/Images/CHfig.png\" style=\"width: 70%; \" title=\"\"/>\n<div class=\"tei-head4\" data-tei=\"1.7.2.17.19.10.7.1.5\">Examples of the latin <span class=\"tei-mentioned\" data-tei=\"1.7.2.17.19.10.7.1.5.2\">a</span>, in both lower and upper case, rendered with different fonts.</div>\n<span class=\"tei-figDesc\" data-tei=\"1.7.2.17.19.10.7.1.7\">Examples of the latin <span class=\"tei-mentioned\" data-tei=\"1.7.2.17.19.10.7.1.7.2\">a</span>, in both lower and upper case, rendered with different fonts.</span>\n</div></p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.10.9\">\n    The word character will not of itself take us\n    very far towards greater terminological precision. It tends to be\n    used to refer indiscriminately both to the visible symbol on a\n    page and to the letter or ideograph which that symbol represents,\n    two things that it is essential to keep conceptually distinct. The\n    visible symbol obviously has some aspects by which we interpret it\n    as representing one character rather than another; but its\n    appearance may also be significantly determined by features that\n    have no effect on our notion of which character in a writing\n    system it represents. A familiar instance is the lowercase\n    <span class=\"tei-mentioned\" data-tei=\"1.7.2.17.19.10.9.4\">a</span>, which in printed texts may be\n    represented either by a single storey symbol\n    (<a class=\"tei-ref3\" data-tei=\"1.7.2.17.19.10.9.8\" href=\"#fig1\" target=\"\">cf. figure 1</a> in the examples from\n    URW Gothic L on the bottom row) or by a two\n    storey version (as in <a class=\"tei-ref3\" data-tei=\"1.7.2.17.19.10.9.12\" href=\"#fig1\" target=\"\">figure\n    1</a> in the examples from Umpush, or URW Bookman L Demi Bold).\n    We say that the single and double-storey symbols both represent\n    one and the same the same abstract\n    character <span class=\"tei-mentioned\" data-tei=\"1.7.2.17.19.10.9.16\">a</span> using two different\n    glyphs. Similarly, an uppercase\n    <span class=\"tei-mentioned\" data-tei=\"1.7.2.17.19.10.9.20\">A</span> in a serif typeface has additional\n    strokes that are absent from the same letter when printed using a\n    sans-serif typeface, so that once again we have differing glyphs\n    standing for the same abstract character. The distinction\n    between abstract characters and glyphs is fundamental to all\n    machine processing of documents.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.10.11\">In most scholarly encoding projects, the accurate recording of\n   the abstract characters which make up the text is of prime\n   importance, because it is the essential prerequisite of\n   digitizing and processing the document without semantic loss. In\n   many cases (though there are important exceptions, to be touched\n   on shortly) it may not be necessary to encode the specific\n   glyphs used to render those abstract characters in the original\n   document. An encoding that faithfully registers the abstract\n   characters of a document allows us to search and analyse our\n   document's content, language, and structure, and to access its full\n   semantics. That same encoding, however, may not contain\n   sufficient information to allow an exact visual representation\n   of the glyphs in the source text or manuscript to be recreated.\n   </p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.10.13\">The importance of this distinction between information content\n   and its visual representation is not always immediately apparent\n   to people unused to the specific complexities of text handling\n   by machine. Such users tend to ask first what (in order of\n   conceptual priority) should actually be their very last\n   question: how do I get a physical image that looks like\n   character x in my source document to appear on to the screen or\n   the output page? Their first question should in fact be: how can\n   I get an abstract representation of character x into my encoded\n   document in a way that will be universally and unambiguously\n   identifiable, no matter what it happens to look like in printout\n   or on any particular display? And occasionally the response they\n   receive as a result of their misguided initial question is a\n   custom solution that satisfies their\n   immediate rendering wishes at the price of making their\n   underlying document unintelligible to other users (or even to\n   the original user in other times and places) because it encodes\n   the abstract character in an idiosyncratic way.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.10.15\">That said, there will certainly be documents or projects where\n   it is a matter of scholarly significance that the compositor or\n   scribe chose to represent a given abstract character using one\n   particular glyph or set of strokes rather than a\n   semantically-equivalent but visually distinct alternative, and\n   in that case the specific appearance of the form will have to be\n   encoded in one way or another. But that encoding need not (and\n   in most cases will not) involve a notation that visually\n   resembles the original, any more than italicized text in an\n   original document will be represented by the use of italic\n   characters in the encoded version.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.10.17\">A collection of the abstract characters needed to represent\n   documents in a given writing system is known as a \n<span class=\"tei-term\" data-tei=\"1.7.2.17.19.10.17.2\">character set</span>, and the character set or\n   <span class=\"tei-term\" data-tei=\"1.7.2.17.19.10.17.4\">character repertoire</span> of a processing or\n   rendering device is the set of abstract characters that it is\n   equipped to recognize and handle appropriately. There is,\n   however, a subtle distinction between these two parallel uses of\n   the same term, involving one more key concept which it is\n   essential to grasp. The character set of a document (or the\n   writing system in which it is recorded) is purely a collection\n   of abstract characters. But the character set of a computing\n   device is a set of abstract characters which have been mapped in\n   a well-defined way to a set of numbers or <span class=\"tei-term\" data-tei=\"1.7.2.17.19.10.17.6\">code points</span> \n   by which the device represents\n   those abstract characters internally. It can therefore be\n   referred to as a <span class=\"tei-term\" data-tei=\"1.7.2.17.19.10.17.8\">coded character set</span>,\n   meaning a set of abstract characters each of which has been\n   assigned a numerical code point (or in some instances a sequence\n   of code points) which unambiguously identifies the character\n   concerned.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.10.19\">It is now possible to use this terminology to\n   say what Unicode is: it is a coded character set, devised and\n   actively maintained by an international public body, where each\n   abstract character is identified by a unique name and assigned a\n   distinctive code point.<a class=\"note tei-note\" data-tei=\"1.7.2.17.19.10.19.2\" href=\"#fn_1_7_2_17_19_10_19_2\" id=\"fnref_1_7_2_17_19_10_19_2\" rel=\"footnote\">3</a> Unicode is \n  distinguished from other coded character sets by its\n  (current and potential) size and scope; its built-in provision\n  for (in practical terms) limitless expansion; the range and\n  quality of linguistic and computational expertise on which it\n  draws; the stability, authority, and accessibility it derives\n  from its status as an international public standard; and,\n  perhaps most importantly, the fact that today it is implemented\n  by almost every provider of hardware and software platforms\n  worldwide.</p> </div>\n<div class=\"tei-div10\" data-tei=\"1.7.2.17.19.12\" id=\"D4-43\">\n<h3 class=\"tei-head9\" data-tei=\"1.7.2.17.19.12.4\">6.2.3 Abstract Characters, Glyphs, and Encoding Scheme\n   Design</h3>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.12.6\">The distinction between abstract characters and glyphs can be\n   crucial when devising an encoding scheme.  When performing \n   searches, text retrieval, or creating concordances, users of \n   electronic text will expect the system to recognize and treat \n   different glyphs as instances of the same character; but when \n   perusing the text itself they may well expect to see glyph variants \n   preserved and rendered. When encoding a pre-existing text, the \n   encoder should determine whether a particular\n   letter or symbol is a character or a glyphic variant. The Unicode \n   Consortium and an ISO work group (ISO/IEC JTC1\n   SC2/WG2) have developed a detailed model of the relationship\n   between characters and glyphs. This model, presented in <a class=\"tei-ref3\" data-tei=\"1.7.2.17.19.12.6.2\" href=\"http://www.unicode.org/reports/tr17/\" target=\"\">Unicode Technical\n     Report 17: Character Encoding Model</a>, is the underpinning\n   of much standards work since, including the current chapter.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.12.8\">The model makes explicit the distinction between two different\n   properties of the components of written language: \n<ul class=\"tei-list3\" data-tei=\"1.7.2.17.19.12.8.2\"><li class=\"tei-item\" data-tei=\"1.7.2.17.19.12.8.2.2\">their content, i.e. its meaning and phonetic value\n    (represented by characters)</li><li class=\"tei-item\" data-tei=\"1.7.2.17.19.12.8.2.4\">their graphical\n    appearance (represented by glyphs).</li></ul>\n</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.12.10\"> When searching for information, a system generally operates\n   on the content aspects of characters,  with little or no\n   attention to their appearance. A layout or formatting process,\n   on the other hand, must of necessity be concerned with the exact\n   appearance of characters. Of course, some operations\n   (hyphenation for example) require attention to both kinds of\n   feature, but in general the kind of text encoding described in\n   these Guidelines tends to focus on content rather than\n   appearance (see further <pb-link class=\"inner-ref\" data-tei=\"1.7.2.17.19.12.10.2\" emit=\"transcription\" hash=\"COHQ\" xml-id=\"COHQ\">3.3 Highlighting and Quotation</pb-link>).</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.12.12\"> An encoder wishing to record information about which glyphs\n   are present in a given document may do so at either or both of\n   two levels:  \n<ul class=\"tei-list3\" data-tei=\"1.7.2.17.19.12.12.2\"><li class=\"tei-item\" data-tei=\"1.7.2.17.19.12.12.2.2\">the level of character encoding, using an appropriate\n    Unicode code point to represent the glyph concerned </li><li class=\"tei-item\" data-tei=\"1.7.2.17.19.12.12.2.4\">the markup level, with the glyph indicated via\n    appropriate elements or attributes</li></ul> </p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.12.14\">The encoding practice adopted may be guided by, among other\n   things, an assessment of the most  frequent uses to which the\n   encoded text will be put. For example, if recognition of\n   identical characters represented by a variety of glyphs is the\n   main priority, it may be advisable to represent the glyph\n   variations at markup level, so that the character value can be\n   immediately exposed to the indexing and retrieval software.\n   Plainly, an encoding project will need to consider such issues\n   carefully and document the outcome of their\n   deliberations in their TEI customization file (or other local\n   encoding documentation) to ensure encoding consistency. Using\n   Unicode code points to represent glyph information requires that\n   such choices be documented in the TEI header. Such documentation\n   cannot of itself guarantee proper display of the desired\n   glyph but at least makes the intention of the encoder\n   discoverable.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.12.16\">At present the Unicode Standard does not offer detailed\n   specifications for the encoding of glyph variations. These\n   Guidelines do give some recommendations; some discussion of\n   related matters is given in <pb-link class=\"inner-ref\" data-tei=\"1.7.2.17.19.12.16.2\" emit=\"transcription\" hash=\"PH\" xml-id=\"PH\">11 Representation of Primary Sources</pb-link>,\n   and  <pb-link class=\"inner-ref\" data-tei=\"1.7.2.17.19.12.16.4\" emit=\"transcription\" hash=\"WD\" xml-id=\"WD\">5 Characters, Glyphs, and Writing Modes</pb-link>  offers some features for the definition of variant\n   glyphs. </p>\n</div>\n<div class=\"tei-div10\" data-tei=\"1.7.2.17.19.14\" id=\"D4-44\">\n<h3 class=\"tei-head9\" data-tei=\"1.7.2.17.19.14.4\">6.2.4 Entry of Characters</h3>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.14.6\">The entry of characters was much more complicated before the near-universal\n    adoption of Unicode, for which there are <span class=\"tei-term\" data-tei=\"1.7.2.17.19.14.6.2\">Input Method Editors</span>\n    (IMEs) available in most languages and fonts that provide glyphs for the full \n    range of the Unicode specification. In those rare situations where there is\n    difficulty entering the specific character you want, or some problem representing\n    it on the system you are working in, <span class=\"tei-term\" data-tei=\"1.7.2.17.19.14.6.4\">Numeric Character References</span>\n    (NCRs) should be used. These take the general form <span class=\"tei-code2 code\" data-tei=\"1.7.2.17.19.14.6.6\">&amp;#D;</span> where \n    <span class=\"tei-code2 code\" data-tei=\"1.7.2.17.19.14.6.8\">D</span> is an integer representing the code point of the character in \n    base 10, or <span class=\"tei-code2 code\" data-tei=\"1.7.2.17.19.14.6.10\">&amp;#xH;</span>, where <span class=\"tei-code2 code\" data-tei=\"1.7.2.17.19.14.6.12\">H</span> is the code point in\n    hexadecimal notation. Every XML processor is capable of recognising NCRs and \n    replacing them with the required code point value without needing access to \n    any additional data. The disadvantage of NCRs as a means of entering, \n    representing and proofing character data is that most human beings find them\n    anything but readable and it is all too easy\n    for the wrong character to be entered in error and retained undetected. \n    Where characters are not defined in Unicode, these Guidelines provide advice\n    on the strategies available for handling their representation in <a class=\"tei-ref3\" data-tei=\"1.7.2.17.19.14.6.16\" href=\"#WD\" target=\"\">Chapter 25 Representation of non-standard Characters and \n    Glyphs</a>. </p>\n</div>\n<div class=\"tei-div10\" data-tei=\"1.7.2.17.19.16\" id=\"D4-45a\">\n<h3 class=\"tei-head9\" data-tei=\"1.7.2.17.19.16.4\">6.2.5 Output of Characters</h3>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.16.6\">The rendering of the encoded text is a complicated process that\n   depends largely on the purpose, external requirements, local\n   equipment and so forth, it is thus outside the scope of coverage\n   for these Guidelines. </p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.16.8\">It might however nevertheless be helpful to put some of the\n   terminology used for the rendering process in the context of the\n   discussion of this chapter.  As was mentioned above, Unicode\n   encodes abstract characters, not specific glyphs.  For any\n   process that makes characters visible, however, concrete,\n   specifically designed glyph shapes have to be used.  For a printing\n   process, for example, these shapes\n   describe exactly at which point ink has to be put on the paper\n   and which areas have to be left blank.  If we want to print a character\n   from the Latin script, besides the selection of\n   the overall glyph shape, this process also requires that a\n   specific weight of the font has been selected, a specific size\n   and to what degree the shape should be slanted.  Beyond\n   individual characters, the overall typesetting process also\n   follows specific rules of how to calculate the distance between\n   characters, how much whitespace occurs between words, at which\n   points line breaks might occur and so forth.  </p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.16.10\">If we concern ourselves only with the rendering process of the\n   characters themselves, leaving out all these other parameters, we\n   will realize that of all the information required for this process, only a small\n   amount will be drawn from the encoded text itself.  This\n   information is the code point used to encode the character in the\n   document.  With this information, the font selected for printing\n   will be queried to provide a glyph shape for this character.\n   Some modern font formats (e.g. OpenType) implement a\n   sophisticated mapping from a code point to the glyph selected,\n   which might take into account surrounding characters (to create\n   ligatures where necessary) and the language or even area this character is\n   printed for to accommodate different typesetting traditions and\n   differences in the usage of glyphs.  </p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.16.12\">A TEI document might provide some of the information that is\n   required for this process, for example by identifying the\n   linguistic context with the xml:lang attribute. The\n   selection of fonts and sizes is usually done in a stylesheet,\n   while the actual layout of a page is determined by the\n   typesetting system used. Similarly, if a document is rendered\n   for publication on the Web, information of this kind can be\n   shipped with the document in a stylesheet.<a class=\"note tei-note\" data-tei=\"1.7.2.17.19.16.12.4\" href=\"#fn_1_7_2_17_19_16_12_4\" id=\"fnref_1_7_2_17_19_16_12_4\" rel=\"footnote\">4</a></p>\n</div>\n<div class=\"tei-div10\" data-tei=\"1.7.2.17.19.18\" id=\"D4-45b\"> <h3 class=\"tei-head9\" data-tei=\"1.7.2.17.19.18.4\">6.2.6 Unicode and\n   XML</h3>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.18.6\">XML was designed with Unicode in mind as its means of representing\n   abstract characters. It is possible to use other character encoding\n   schemes, but in general they are best avoided, as you run the risk \n   of encountering compatibility issues with different XML processors,\n   as well as potential difficulties with rendering their output. We \n   recommend using the <span class=\"tei-term\" data-tei=\"1.7.2.17.19.18.6.2\">UTF-8</span> encoding, which for the Basic\n   Latin range is identical to ASCII, and which uses a variable-length\n   set of bytes to represent characters. It should be noted that it is\n   not sufficient simply to declare in the XML Declaration that a document\n   is in UTF-8 format. Doing so merely means that processors will treat the\n   content therein as if it were UTF-8, and may fail to process the \n   document if it is not. For further discussion of UTF-8, see the \n   section below on <pb-link class=\"inner-ref\" data-tei=\"1.7.2.17.19.18.6.4\" emit=\"transcription\" hash=\"D4-48\" xml-id=\"D4-48\">6.2.8 Issues Arising from the Internal Representations of\n   Unicode</pb-link>.</p>\n</div>\n<div class=\"tei-div10\" data-tei=\"1.7.2.17.19.20\" id=\"D4-46\">\n<h3 class=\"tei-head9\" data-tei=\"1.7.2.17.19.20.4\">6.2.7 Special Aspects of Unicode Character Definitions</h3>\n<div class=\"tei-div10\" data-tei=\"1.7.2.17.19.20.6\" id=\"D4-46-1\">\n<h4 class=\"tei-head9\" data-tei=\"1.7.2.17.19.20.6.4\">6.2.7.1 Compatibility Characters</h4>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.20.6.6\">The principles of Unicode are judiciously tempered with\n   pragmatism. This means, among other things, that the actual\n   repertoire of characters which the standard encodes, especially\n   those parts dating from its earlier days, include a number of\n   items which on a strict interpretation of the Unicode\n   Consortium's theoretical approach should not have been regarded\n   as abstract characters in their own right. Some of these\n   characters are grouped together into a\n   code-point regions assigned to  <span class=\"tei-term\" data-tei=\"1.7.2.17.19.20.6.6.4\">compatibility characters</span>.\n   Ligatures are a case in point. Ligatures (e.g. the joining of\n   adjacent lowercase letters <span class=\"tei-q2\" data-tei=\"1.7.2.17.19.20.6.6.6\">s</span> and <span class=\"tei-q2\" data-tei=\"1.7.2.17.19.20.6.6.8\">t</span> or <span class=\"tei-q2\" data-tei=\"1.7.2.17.19.20.6.6.10\">f</span> and <span class=\"tei-q2\" data-tei=\"1.7.2.17.19.20.6.6.12\">i</span> in Latin\n   scripts, whether produced by a scribal practice of not lifting\n   the pen between strokes or dictated by the aesthetics of a type\n   design) are representational features with no added semantic\n   value beyond that of the two letters they unite (though for\n   historians of typography their presence and form in a given\n   edition may be of scholarly significance). However, by the time\n   the Unicode standard was first being debated, it had become\n   common practice to include single glyphs representing the more\n   common ligatures in the  repertoires of some typesetting devices\n   and high-end printers, and for the coded character sets built\n   into those devices to use a single code point for such glyphs,\n   even though they represent two distinct abstract characters. So\n   as to increase the acceptance of Unicode among the makers and\n   users of such devices, it was agreed that some such\n   pseudo-characters should be incorporated into the standard as compatibility characters.\n   Nevertheless, if a project requires the presence of such\n   ligatured forms to be encoded, this should normally be done via\n   markup, not by the use of a compatibility character. That way,\n   the presence of the ligature can still be identified (and, if\n   desired, rendered visually) where appropriate, but indexing and\n   retrieval software will treat the code points in the document as\n   a simple sequential occurrence of the two constituent characters\n   concerned and so correctly align their semantics with\n   non-ligatured equivalents. Such ligatures should not be confused\n   with digraphs (usually) indicating diphthongs, as in the French\n   word \"cœur\". A digraph is an atomic orthographic unit\n   representing an abstract character in its own right, not purely an amalgamation\n   of glyphs, and indexing and retrieval software will need to \n   treat it as such. Where a digraph occurs in a source text, it\n   should normally be encoded using the appropriate code point for\n   the single abstract character which it represents. </p> </div>\n<div class=\"tei-div10\" data-tei=\"1.7.2.17.19.20.8\" id=\"D4-46-2\">\n<h4 class=\"tei-head9\" data-tei=\"1.7.2.17.19.20.8.4\">6.2.7.2 Precomposed and Combining Characters and\n   Normalization</h4>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.20.8.6\">The treatment of characters with\n   diacritical marks within Unicode shows a similar combination of\n   rigour and pragmatism. It is obvious enough that it would be\n   feasible to represent many characters with diacritical marks in\n   Latin and some other scripts by a sequence of code points, where\n   one code point designated the base character and the remainder\n   represented one or more diacritical marks that were to be\n   combined with the base character to produce an appropriate\n   glyphic rendering of the abstract character concerned. From its\n   earliest phase, the Unicode Consortium espoused this view in\n   theory but was prepared in practice to compromise by assigning\n   single code points to <span class=\"tei-term\" data-tei=\"1.7.2.17.19.20.8.6.2\">precomposed</span> characters which were\n   already commonly assigned a single distinctive code point in\n   existing encoding schemes. This means, however, that for quite a\n   large number of commonly-occurring abstract characters, Unicode\n   has two different, but logically and semantically equivalent\n   encodings: a <span class=\"tei-term\" data-tei=\"1.7.2.17.19.20.8.6.4\">precomposed</span> single code point, and a code point\n   sequence of a base character plus one or more <span class=\"tei-term\" data-tei=\"1.7.2.17.19.20.8.6.6\">combining</span>\n   diacritics. Scripts more recently added to Unicode no longer\n   exhibit this code-point duplication (in current practice no new\n   precomposed characters are defined where the use of combining\n   characters is possible) but this does nothing to remove the\n   problem caused by the duplications from older character sets that \n   have been permanently embodied in Unicode. Together with essentially analogous\n   issues arising from the encoding of certain East Asian\n   ideographs. This duplication gives rise to the need to practice\n   <span class=\"tei-term\" data-tei=\"1.7.2.17.19.20.8.6.8\">normalization</span> of Unicode documents. Normalization is\n   the process of ensuring that a given abstract character is represented in one\n   way only in a given Unicode document or document collection.\n   The Unicode Consortium provides four standard normalization\n   forms, of which the <span class=\"tei-term\" data-tei=\"1.7.2.17.19.20.8.6.10\">Normalization Form C</span> (NFC)\n   seems to be most appropriate for text encoding projects. The NFC, as \n   far as possible, defines conversions for all base characters followed \n   by one or more combining characters into the corresponding precomposed \n   characters. The World Wide Web Consortium has produced a document entitled\n   <span class=\"tei-title5\" data-tei=\"1.7.2.17.19.20.8.6.12\">Character Model for the World Wide Web 1.0</span><a class=\"note tei-note\" data-tei=\"1.7.2.17.19.20.8.6.13\" href=\"#fn_1_7_2_17_19_20_8_6_13\" id=\"fnref_1_7_2_17_19_20_8_6_13\" rel=\"footnote\">5</a>, which among other things\n   discusses normalization issues and outlines some relevant\n   principles. An authoritative reference is Unicode Standard Annex\n   #15 <span class=\"tei-title5\" data-tei=\"1.7.2.17.19.20.8.6.15\">Unicode Normalization Forms</span><a class=\"note tei-note\" data-tei=\"1.7.2.17.19.20.8.6.16\" href=\"#fn_1_7_2_17_19_20_8_6_16\" id=\"fnref_1_7_2_17_19_20_8_6_16\" rel=\"footnote\">6</a>. </p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.20.8.8\">It is important that every Unicode-based project should agree\n   on, consistently implement, and fully document a comprehensive and\n   coherent normalization practice. As well as ensuring data integrity\n   within a given project, a consistently implemented and properly\n   documented normalization policy is essential for successful\n   document interchange. While different input methods may themselves differ\n   in what normalization form they use, any programming language that implements Unicode\n   will provide mechanisms for converting between normalization forms, so it \n   is easy in practice to ensure that all documents in a project are in a consistent form,\n   even if different methods are used to enter data.</p>\n</div>\n<div class=\"tei-div10\" data-tei=\"1.7.2.17.19.20.10\" id=\"D4-46-3\">\n<h4 class=\"tei-head9\" data-tei=\"1.7.2.17.19.20.10.4\">6.2.7.3 Character Semantics</h4>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.20.10.6\">In addition to the Universal Character Set itself, the\n    Unicode Consortium maintains a database of additional character\n    semantics<a class=\"note tei-note\" data-tei=\"1.7.2.17.19.20.10.6.2\" href=\"#fn_1_7_2_17_19_20_10_6_2\" id=\"fnref_1_7_2_17_19_20_10_6_2\" rel=\"footnote\">7</a>. This\n    includes names for each character code point and normative\n    properties for it.  Character properties, as given in this\n    database, determine the semantics and thus the intended use of a\n    code point or character. The database also contains information that might be\n    needed for correctly processing this character for different\n    purposes. It is an important reference in determining which Unicode \n    code point to use to encode a certain character.  </p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.20.10.8\">In addition to the printed documentation and lists made\n   available by the Unicode consortium, the information it contains\n   may also be accessed by a number of search systems over the Web\n   (e.g. <span class=\"tei-ptr4\" data-tei=\"1.7.2.17.19.20.10.8.2\"><a href=\"http://www.eki.ee/letter/\">http://www.eki.ee/letter/</a></span>). Examples of\n   character properties included in the database include case, numeric\n   value, directionality, and, (where applicable) status as a\n   compatibility character<a class=\"note tei-note\" data-tei=\"1.7.2.17.19.20.10.8.5\" href=\"#fn_1_7_2_17_19_20_10_8_5\" id=\"fnref_1_7_2_17_19_20_10_8_5\" rel=\"footnote\">8</a>. Where a\n   project undertakes local definition of characters with code points\n   in the PUA, it is desirable that any relevant additional\n   information about the characters concerned should be recorded in an\n   analogous way, as further discussed under <pb-link class=\"inner-ref\" data-tei=\"1.7.2.17.19.20.10.8.7\" emit=\"transcription\" hash=\"WD\" xml-id=\"WD\">5 Characters, Glyphs, and Writing Modes</pb-link>.</p>\n</div>\n</div>\n<div class=\"tei-div10\" data-tei=\"1.7.2.17.19.22\" id=\"D4-48\">\n<h3 class=\"tei-head9\" data-tei=\"1.7.2.17.19.22.4\">6.2.8 Issues Arising from the Internal Representations of\n   Unicode</h3>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.22.6\">In theory it should not be necessary for encoders to have any\n   knowledge of the various ways in which Unicode code points can\n   be represented internally within a document or in the memory of\n   a processing system, but experience shows that problems\n   frequently arise in this area because of mistaken practice or\n   defective software, and in order to recognize the resulting\n   symptoms and correct their causes an outline knowledge of\n   certain aspects of Unicode internal representation is desirable.\n   There are three encodings of Unicode available for use: UTF-8, which\n   uses 1–4 bytes per character, UTF-16, which uses 2–4, and UTF-32,\n   which uses 4 bytes per character. Current practice for documents to\n   be transmitted via the Web recommends only UTF-8.<a class=\"note tei-note\" data-tei=\"1.7.2.17.19.22.6.2\" href=\"#fn_1_7_2_17_19_22_6_2\" id=\"fnref_1_7_2_17_19_22_6_2\" rel=\"footnote\">9</a>\n</p>\n<div class=\"tei-div10\" data-tei=\"1.7.2.17.19.22.8\" id=\"D4-48-1\">\n<h4 class=\"tei-head9\" data-tei=\"1.7.2.17.19.22.8.4\">6.2.8.1 Encoding Errors Related to UTF-8</h4>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.22.8.6\">The code points assigned by Unicode 3.0 and later are\n    notionally 32-bit integers, and the most straightforward way to\n    represent each such integer in computer storage would be to use\n    4 eight-bit bytes. However, many of the code points for\n    characters most commonly used in Latin scripts can be\n    represented in one byte only and the vast majority of the\n    remainder which are in common use (including those assigned\n    from the most frequently used PUA range) can be expressed in\n    two bytes alone. This accounts for the use of UTF-8 and UTF-16\n    and their special place in the XML standard. UTF-8 and UTF-16\n    are ways of representing 32-bit code points in an economical\n    way. </p><p class=\"tei-p\" data-tei=\"1.7.2.17.19.22.8.7\">UTF-8 is a variable length encoding: the more\n    significant bits there are in the underlying code point (or in\n    everyday terminology the bigger the number used to represent\n    the character), the more bytes UTF-8 uses to encode it. What\n    makes UTF-8 particularly attractive for representing Latin\n    scripts, explaining its status as the default encoding in XML\n    documents, is that all code points that can be expressed in\n    seven or fewer bits (the 127 values in the original ASCII\n    character set) are also encoded as the same seven or fewer bits\n    (and therefore in a single byte) in UTF-8. That is why a\n    document which is actually encoded in pure 7-bit ASCII can be\n    fed to an XML processor without alteration and without its\n    encoding being explicitly declared: the processor will regard\n    it as being in the UTF-8 representation of Unicode and be able\n    to handle it correctly on that basis.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.22.8.9\">However, even within the domain of Latin-based scripts, some\n    projects have documents which use characters from 8 bit\n    extensions to ASCII, e.g. those in the ISO-8859-n series of\n    encodings, and the way characters which under ISO-8859-n use\n    all eight bits are encoded in UTF-8 is significantly different,\n    giving rise to puzzling errors. Abstract characters that have a\n    single byte code point where the\n    highest bit is set (that is, they have a decimal numeric\n    representation between 129 and 255) are encoded in ISO-8859-n\n    as a single byte with the same value\n    as the code point. But in UTF-8 code-point values inside that\n    range are expressed as a two byte\n    sequence. That is to say, the abstract character in question is\n    no longer represented in the file or in memory by the same number\n    as its code-point value: it is <span class=\"tei-hi2\" data-tei=\"1.7.2.17.19.22.8.9.8\">transformed</span> (hence the T in\n    UTF) into a sequence of two different numbers. Now as a\n    side-effect of the way such  UTF-8 sequences are derived from\n    the underlying code-point value, many of the single-byte\n    eight-bit values employed in ISO-8859-n encodings are illegal\n    in UTF-8.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.22.8.11\">This complicated situation has a simple consequence which can\n    cause great bewilderment. XML processors will effortlessly\n    handle character data in pure 7-bit ASCII without that encoding\n    needing to be declared to the parser, and will similarly accept\n    documents encoded in an undeclared ISO-8859-n encoding if they\n    happen to use no characters outside the strict ASCII subset of\n    the ISO character sets; but the parse will immediately fail if\n    an eight-bit character from an ISO-8859-n set is encountered in\n    the input stream, unless the document's encoding has been\n    explicitly and correctly declared. Explicitly declaring the\n    encoding ought to solve the problem, and if the file is\n    correctly encoded throughout, it will do so. But projects dealing \n    with documents of sufficient age may find that they have to deal with some files  encoded\n    in UTF-8 along with others in, say, ISO-8859-1. Such encoding\n    differences may go unnoticed, especially if the proportion of\n    characters where the internal encodings are distinguishable is\n    relatively small (for example in a long English text with a\n    smattering of French words). These types of error may or may not\n    manifest in actual processing errors, and may only become visible\n    as garbage characters in the eventual display of documents.</p>\n<p class=\"tei-p\" data-tei=\"1.7.2.17.19.22.8.13\">In projects that routinely handle documents in non-Latin\n    scripts, everyone is well aware of the need to ensure correct\n    and consistent encoding, so in such places mixed encoding\n    problems seldom arise, and when they do are readily identified\n    and remedied. Real confusion tends to arise, however, in\n    projects which have a low awareness of the issues because they\n    employ predominantly unaccented Latin characters, with only\n    thinly-distributed instances of accented letters, or other\n    special characters where the internal representation under\n    ISO-8859-n and UTF-8 are different (such as the copyright\n    symbol, or, a frequent troublemaker where eventual HTML output\n    is envisaged, the non-breaking space). Even, or especially,\n    if such projects view themselves as concerned only with\n    English documents, the close relationship between XML and\n    Unicode means they will need to acquire an understanding of\n    these encoding issues and develop procedures which assure\n    consistency and integrity of encoding and its correct\n    declaration, including the use of appropriate software for\n    transcoding and verification. </p> </div>\n</div>\n</div>\n</section><div class=\"popovers\"></div></div>", "footnotes": "<!DOCTYPE html>\n<div class=\"footnotes\"><dl class=\"footnote\" id=\"fn_1_7_2_17_17_7_5\"><dt class=\"fn-number\">1</dt><dd data-tei=\"1.7.2.17.17.7.5\" class=\"fn-content\">Currently\nBCP 47 comprises two Internet Engineering Task Force documents,\nreferred to separately as RFC 5646 and RFC 4647; over time, other IETF\ndocuments may succeed these as the best current practice.<a class=\"fn-back\" href=\"#fnref_1_7_2_17_17_7_5\">↩</a></dd></dl><dl class=\"footnote\" id=\"fn_1_7_2_17_17_19_4\"><dt class=\"fn-number\">2</dt><dd data-tei=\"1.7.2.17.17.19.4\" class=\"fn-content\">This excludes all attributes where a non-textual\ndatatype has been specified, for example tokens, boolean values,\ndates, and predefined value lists.<a class=\"fn-back\" href=\"#fnref_1_7_2_17_17_19_4\">↩</a></dd></dl><dl class=\"footnote\" id=\"fn_1_7_2_17_19_10_19_2\"><dt class=\"fn-number\">3</dt><dd data-tei=\"1.7.2.17.19.10.19.2\" class=\"fn-content\">Although only Unicode\n    is mentioned here explicitly, it should be noted that the\n    character repertoire and assigned code points of Unicode and\n    the ISO standard 10646 are identical and maintained in a way\n    that ensures this continues to be the case. <a class=\"fn-back\" href=\"#fnref_1_7_2_17_19_10_19_2\">↩</a></dd></dl><dl class=\"footnote\" id=\"fn_1_7_2_17_19_16_12_4\"><dt class=\"fn-number\">4</dt><dd data-tei=\"1.7.2.17.19.16.12.4\" class=\"fn-content\">The World Wide\n   Web Consortium provides recommendations for two standard\n   stylesheet languages: either CSS or\n   XSL could be used for this purpose.<a class=\"fn-back\" href=\"#fnref_1_7_2_17_19_16_12_4\">↩</a></dd></dl><dl class=\"footnote\" id=\"fn_1_7_2_17_19_20_8_6_13\"><dt class=\"fn-number\">5</dt><dd data-tei=\"1.7.2.17.19.20.8.6.13\" class=\"fn-content\">Available at\n    <span data-tei=\"1.7.2.17.19.20.8.6.13.3\" class=\"tei-ptr4\"><a href=\"http://www.w3.org/TR/charmod/\">http://www.w3.org/TR/charmod/</a></span>.<a class=\"fn-back\" href=\"#fnref_1_7_2_17_19_20_8_6_13\">↩</a></dd></dl><dl class=\"footnote\" id=\"fn_1_7_2_17_19_20_8_6_16\"><dt class=\"fn-number\">6</dt><dd data-tei=\"1.7.2.17.19.20.8.6.16\" class=\"fn-content\">available at\n    <span data-tei=\"1.7.2.17.19.20.8.6.16.3\" class=\"tei-ptr4\"><a href=\"http://www.unicode.org/reports/tr15/\">http://www.unicode.org/reports/tr15/</a></span><a class=\"fn-back\" href=\"#fnref_1_7_2_17_19_20_8_6_16\">↩</a></dd></dl><dl class=\"footnote\" id=\"fn_1_7_2_17_19_20_10_6_2\"><dt class=\"fn-number\">7</dt><dd data-tei=\"1.7.2.17.19.20.10.6.2\" class=\"fn-content\"><span data-tei=\"1.7.2.17.19.20.10.6.2.2\" class=\"tei-ptr4\"><a href=\"http://www.unicode.org/ucd/\">http://www.unicode.org/ucd/</a></span><a class=\"fn-back\" href=\"#fnref_1_7_2_17_19_20_10_6_2\">↩</a></dd></dl><dl class=\"footnote\" id=\"fn_1_7_2_17_19_20_10_8_5\"><dt class=\"fn-number\">8</dt><dd data-tei=\"1.7.2.17.19.20.10.8.5\" class=\"fn-content\">For\n   further details, see <span data-tei=\"1.7.2.17.19.20.10.8.5.3\" class=\"tei-title5\">The Unicode Character Property\n   Model</span> (Unicode Technical Report #23), at <span data-tei=\"1.7.2.17.19.20.10.8.5.5\" class=\"tei-ptr4\"><a href=\"http://www.unicode.org/reports/tr23/\">http://www.unicode.org/reports/tr23/</a></span>.<a class=\"fn-back\" href=\"#fnref_1_7_2_17_19_20_10_8_5\">↩</a></dd></dl><dl class=\"footnote\" id=\"fn_1_7_2_17_19_22_6_2\"><dt class=\"fn-number\">9</dt><dd data-tei=\"1.7.2.17.19.22.6.2\" class=\"fn-content\">See the W3C \n   Internationalization document, <span data-tei=\"1.7.2.17.19.22.6.2.3\" class=\"tei-title5\">Choosing &amp; applying a \n   character encoding</span> at \n     <span data-tei=\"1.7.2.17.19.22.6.2.5\" class=\"tei-ptr4\"><a href=\"https://www.w3.org/International/questions/qa-choosing-encodings\">https://www.w3.org/International/questions/qa-choosing-encodings</a></span><a class=\"fn-back\" href=\"#fnref_1_7_2_17_19_22_6_2\">↩</a></dd></dl></div>", "userParams": {"track-ids": "True", "webcomponents": 7, "lng": "en"}, "collection": ""}